[toc]

### rabbitmq-api

```markdown
rabbitmq
├── d01_quickstart -- 快速入门
├── d02_exchange -- direct fanout topic 交换机
├── d03_basic_get -- 使用通道的basicGet获取消息
├── d04_broker_confirm -- 消息可靠投递: 确保消息成功投递进broker broker的confirm机制 同步和异步确认，异步使用ConfirmListener
├── d05_broker_mandatory -- 消息可靠投递: 确保消息成功从交换机路由到队列 mandatory机制 ReturnListener
├── d06_consumer_ack -- 消息可靠投递: 确保消费者消费消息 ack机制，需要手动确认消费的消息在未被确认的情况下会分发到其他监听此队列的消费者消费
├── d07_nack_reject -- 消息可靠投递: nack和reject功能基本一致，消息在消费失败时候重回队列的设置
├── d08_ae_exchange -- 备份交换机: 当交换机无法根据路由匹配到任意一个队列时，交换机会将消息转发到备份交换机中进行处理
├── d09_dead_letter_queue -- 死信队列，延时消息投递 (死信交换机和死信队列消息来源: 客户端拒绝且不重回队列的消息、超过TTL的消息、消息队列满)
├── d10_transaction -- 事务(不推荐) 分布式事务中使用confirm、mandatory和ack机制来确保消息正确消费
└── d11_qos -- 限流策略: 客户端保护(不配置限流的情况下，rabbitmq会尽可能快的将消息推送到客户端)，合理的配置qos会有效提高吞吐量
```

#### 一、消息的可靠投递
 `confirm`: 保证消息从上游生产者投递到mq中

 `mandatory`: 保证消息路由到队列中

 `ack nack`: 保证消息正确的被下游消费者消费

##### 方案一 消息状态更新+定时任务推送失败消息+人工处理重试超上限的消息
```markdown
1.生产者发送消息前，将消息入库，设置状态为准备发送，重试次数为0，发送时间为当前时间
2.confirm回调成功，修改状态消息状态为1
3.开启一个定时任务，拉取消息库中状态为0，当前时间-发送时间>回调时间阈值 && 重试次数在限制内的消息，重新发送。
4.重复1-3步。
5.人工处理消息重试次数超限制的消息
```

##### 方案二 延时消息检查(架构实现)
```markdown
1.上游生产者在发送消息之前将业务消息入库
2.生产者发送业务消息
3.延时5-10min后(延时可以根据业务调整)，生产者发送一条检查消息(这条消息由检查服务消费)
4.下游消费者将消息处理完成后，投递一条处理成功的消息(这条消息由检查服务消费)
5.消息检查服务监听到处理成功的消息，就持久化到DB中
6.消息检查服务监听到延时检查消息，从DB中查询检查是否存在这条消息，若不存在，消息检查服务主动发起RPC通信通知上游生产者需要重新发送这条消息
7.上游消费者重新获取业务消息重新发送，重复上述检查流程
```

#### 二、消息幂等性


#### 三、消息消费的顺序性